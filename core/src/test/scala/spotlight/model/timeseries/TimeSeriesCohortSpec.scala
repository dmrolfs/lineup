package spotlight.model.timeseries

import com.github.marklister.collections._
import spotlight.model.timeseries.TimeSeriesCohort.TimeFrame
import scala.annotation.tailrec
import scala.concurrent.duration.SECONDS
import org.scalatest._
import org.joda.{ time ⇒ joda }
import com.github.nscala_time.time.Imports._
import peds.commons.log.Trace
import peds.commons.math.Interpolator

class TimeSeriesCohortSpec
    extends fixture.WordSpec
    with MustMatchers
    with ParallelTestExecution
    with TryValues {
  import TimeSeriesCohortSpec._

  val trace = Trace[TimeSeriesCohortSpec]

  type Fixture = TestFixture
  override type FixtureParam = Fixture

  class TestFixture { outer ⇒
    // logistic map sequences generated by: http://sprott.physics.wisc.edu/cdg.htm
    def generateTimeSequence( name: String, ys: Seq[Double], unit: Long = 1000L, origin: joda.DateTime = joda.DateTime.now ): Seq[DataPoint] = trace.block( s"generateTimeSequence($name, $origin)" ) {
      val xs = ( 0 until ys.size ) map { i ⇒ origin + ( i * unit ) }
      xs.toIndexedSeq.zip( ys ).map { xy ⇒ DataPoint( timestamp = xy._1, value = xy._2 ) }
    }

    val series1 = TimeSeries( topic = "series.one", points = generateTimeSequence( "series1", s1 ) )
    trace( s"""series1 = ${series1.points.mkString( "," )}""" )
    val series2 = TimeSeries( topic = "series.two", points = generateTimeSequence( "series2", s2 ) )
    trace( s"""series2 = ${series2.points.mkString( "," )}""" )
    val series3 = TimeSeries( topic = "series.three", points = generateTimeSequence( "series3", s3 ) )
    val series4 = TimeSeries( topic = "series.four", points = generateTimeSequence( "series4", s4 ) )

    val briefCohort = TimeSeriesCohort(
      TimeSeries( topic = "series.one", points = generateTimeSequence( "series.one", s1 take 4 ) ),
      TimeSeries( topic = "series.two", points = generateTimeSequence( "series.two", s2 take 4 ) ),
      TimeSeries( topic = "series.three", points = generateTimeSequence( "series.three", s3 take 4 ) ),
      TimeSeries( topic = "series.four", points = generateTimeSequence( "series.four", s4 take 4 ) )
    )

    val cohortBySecond = TimeSeriesCohort( data = IndexedSeq( series1, series2, series3, series4 ), precision = SECONDS )

    def massage( series: Seq[DataPoint], frames: Stream[TimeFrame] ): Seq[DataPoint] = {
      def frameIndex: joda.DateTime ⇒ Int = {
        val intervals = frames map { _.bounds }
        ( pt: joda.DateTime ) ⇒ { intervals indexWhere { _.contains( pt ) } }
      }

      def groupByFrame( ser: Seq[DataPoint] ): Seq[Seq[DataPoint]] = {
        @tailrec def loop( data: List[DataPoint], fr: List[TimeFrame], acc: IndexedSeq[IndexedSeq[DataPoint]] ): IndexedSeq[IndexedSeq[DataPoint]] = {
          //          trace( s"""loop..data:[${data.mkString(",")}]""")
          //          trace( s"""loop..fr:[${fr.mkString(",")}]""")
          trace( s"""loop..acc:[${acc.mkString( "," )}]""" )

          data match {
            case Nil ⇒ acc
            case h :: tail ⇒ {
              val findex = frameIndex( h.timestamp )
              trace( s"""FINDEX = $findex  target:[${h.timestamp}]  frames:[${frames.mkString( "," )}]""" )
              val newCur = acc( findex ) :+ h
              loop( tail, fr, acc.updated( findex, newCur ) )
            }
          }
        }

        loop( ser.toList, frames.toList, IndexedSeq.fill( frames.size )( IndexedSeq.empty[DataPoint] ) )
      }

      //      trace( s"""FIRST[${series.map(_.timestamp.getMillis).min}] - LAST[${series.map(_.timestamp.getMillis).max}]""" )
      //      trace( s"""FRAMES:[\n${frames.map(f => (f._1.getMillis, f._2.getMillis, f._3.getMillis)).mkString("\n")}\n]""")

      for {
        group ← groupByFrame( series )
        xs = group map { _.timestamp.getMillis.toDouble }
        ys = group map { _.value }
      } yield {
        if ( group.isEmpty ) DataPoint( new joda.DateTime( 0L ), 0D )
        else if ( group.size == 1 ) DataPoint( new joda.DateTime( xs.head.toLong ), ys.head )
        else {
          val result = Interpolator( xs.toArray, ys.toArray ) map { interpolate ⇒
            val getFrame = frames.lift
            getFrame( frameIndex( group.head.timestamp ) ) map { f ⇒
              DataPoint( f.mid, interpolate( f.mid.getMillis.toDouble ) )
            } getOrElse DataPoint( new DateTime( 0L ), 0D )
          }
          result valueOr { exs ⇒ throw exs.head }
        }
      }
    }

    def row( r: Product4[DataPoint, DataPoint, DataPoint, DataPoint] ): IndexedSeq[( joda.DateTime, Double )] = {
      r.productIterator.toIndexedSeq.map { case dp: DataPoint ⇒ ( dp.timestamp, dp.value ) }
    }

    def compareApproximateCohorts(
      actual: Matrix[( joda.DateTime, Double )],
      expected: IndexedSeq[IndexedSeq[( joda.DateTime, Double )]],
      timeEps: Long = 1,
      valueEps: Double = 0.0000000000001
    ): Int = {
      @tailrec def loop( data: List[( ( joda.DateTime, Double ), ( joda.DateTime, Double ) )], acc: Int ): Int = data match {
        case Nil ⇒ acc
        case d if acc != 0 ⇒ acc
        case h :: tail ⇒ {
          val ( a, e ) = h
          val timeCompare = {
            val aLow = a._1.getMillis - timeEps
            val aHigh = a._1.getMillis + timeEps
            if ( aLow <= e._1.getMillis && e._1.getMillis <= aHigh ) 0 else {
              trace( s"TIME: out of bounds: actual:[${a._1}|${a._1.getMillis}}]  expected:[${e._1}|${e._1.getMillis}}]  var:[${e._1.getMillis - a._1.getMillis}] eps:${timeEps}" )
              a._1 compareTo e._1
            }
          }

          if ( timeCompare != 0 ) loop( tail, timeCompare )
          else {
            val valueCompare = {
              val aLow = a._2 - valueEps
              val aHigh = a._2 + valueEps
              if ( aLow <= e._2 && e._2 <= aHigh ) 0 else {
                trace( s"VALUE: out of bounds: actual:[${a._2} @ ${a._1}|${a._1.getMillis}}]  expected:[${e._2} @ ${e._1}|${e._1.getMillis}}]  var:[${e._2 - a._2}}]  eps:[${valueEps}]" )
                a._2 compareTo e._2
              }
            }

            loop( tail, valueCompare )
          }
        }
      }

      val factual: IndexedSeq[( joda.DateTime, Double )] = actual.flatten
      val fexpected: IndexedSeq[( joda.DateTime, Double )] = expected.flatten
      val together: IndexedSeq[( ( joda.DateTime, Double ), ( joda.DateTime, Double ) )] = factual zip fexpected
      loop( together.toList, 0 )
    }
  }

  def createTestFixture(): Fixture = trace.block( "createTestFixture" ) { new Fixture }

  override def withFixture( test: OneArgTest ): Outcome = {
    val fixture = createTestFixture()
    try {
      test( fixture )
    } finally {
    }
  }

  object WIP extends Tag( "wip" )

  "TimeSeriesCohort" should {
    "determine common name prefix" in { f: Fixture ⇒
      Topic.findAncestor() mustBe Topic( "" )
      Topic.findAncestor( "hyperactive", "hyperbolic", "hyperacuity", "hyperaesthesias" ) mustBe Topic( "hyper" )
      Topic.findAncestor( "hyper.active", "hyper.bolic", "hyper.acuity", "hyper.aesthesias" ) mustBe Topic( "hyper" )
      Topic.findAncestor( "foo", "bar", "zed" ) mustBe Topic( "" )
    }

    "start at beginning of all time series points" in { f: Fixture ⇒
      val times: IndexedSeq[joda.DateTime] = for {
        series ← f.briefCohort.data
        pt ← series.points
      } yield pt.timestamp

      f.briefCohort.start mustBe Some( times.min )
    }

    "end at last of all time series points" in { f: Fixture ⇒
      val times: IndexedSeq[joda.DateTime] = for {
        series ← f.briefCohort.data
        pt ← series.points
      } yield pt.timestamp

      f.briefCohort.end mustBe Some( times.max )
    }

    "stream time frames" in { f: Fixture ⇒
      val now = joda.DateTime.now

      val e1 = IndexedSeq(
        TimeFrame( bounds = now to now + 1000, mid = now + 500 ),
        TimeFrame( bounds = now + 1000 to now + 2000, mid = now + 1500 ),
        TimeFrame( bounds = now + 2000 to now + 3000, mid = now + 2500 ),
        TimeFrame( bounds = now + 3000 to now + 4000, mid = now + 3500 ),
        TimeFrame( bounds = now + 4000 to now + 5000, mid = now + 4500 ),
        TimeFrame( bounds = now + 5000 to now + 5000 + 1, mid = now + 5000 )
      )
      TimeSeriesCohort.timeframes( now, now + 5000, 1000 ).take( 10 ) mustBe e1

      val e2 = IndexedSeq(
        TimeFrame( bounds = now to now + 613, mid = now + 306 ),
        TimeFrame( bounds = now + 613 to now + 1226, mid = now + 919 ),
        TimeFrame( bounds = now + 1226 to now + 1839, mid = now + 1532 ),
        TimeFrame( bounds = now + 1839 to now + 2452, mid = now + 2145 ),
        TimeFrame( bounds = now + 2452 to now + 3065, mid = now + 2758 ),
        TimeFrame( bounds = now + 3065 to now + 3678, mid = now + 3371 ),
        TimeFrame( bounds = now + 3678 to now + 4291, mid = now + 3984 ),
        TimeFrame( bounds = now + 4291 to now + 4904, mid = now + 4597 ),
        TimeFrame( bounds = now + 4904 to now + 5000 + 1, mid = now + 4952 )
      )
      val a2 = TimeSeriesCohort.timeframes( now, now + 5000, 613 ).take( 10 )
      a2.zip( e2 ).zipWithIndex foreach { ae_i ⇒
        //        println( s"eval index[${ae_i._2}}] (${ae_i._1._1.bounds.getStartMillis}-${ae_i._1._1.bounds.getEndMillis} / ${ae_i._1._1.mid.getMillis}}) ?==? (${ae_i._1._2.bounds.getStartMillis}-${ae_i._1._2.bounds.getEndMillis} / ${ae_i._1._2.mid.getMillis}})" )
        ae_i._1._1 mustBe ae_i._1._2
      }
      a2 mustBe e2
    }

    "convert brief cohort to matrix" taggedAs ( WIP ) in { f: Fixture ⇒
      import f._

      val e1 = briefCohort.data( 0 ).points zip briefCohort.data( 1 ).points zip briefCohort.data( 2 ).points zip briefCohort.data( 3 ).points
      val expected = e1 map { t ⇒
        IndexedSeq(
          ( t._1._1._1.timestamp, t._1._1._1.value ),
          ( t._1._1._2.timestamp, t._1._1._2.value ),
          ( t._1._2.timestamp, t._1._2.value ),
          ( t._2.timestamp, t._2.value )
        )
      }

      val e2 = briefCohort.data( 0 ).points flatZip briefCohort.data( 1 ).points flatZip briefCohort.data( 2 ).points flatZip briefCohort.data( 3 ).points
      val expected2 = IndexedSeq( row( e2( 0 ) ), row( e2( 1 ) ), row( e2( 2 ) ), row( e2( 3 ) ) )
      expected2 mustBe expected
      val actual = briefCohort.toMatrix
      //      println( s"\n>>> cohort:${briefCohort}" )
      //      println( s"\n>>> actual:$actual" )
      //      println( s"\n>>> expected:$expected" )
      //      ( actual zip expected ) foreach println
      actual mustBe expected
    }

    "convert double-time cohort to matrix" in { f: Fixture ⇒
      import f._

      val series1 = generateTimeSequence( "series1-500", s1 take 8, 500 )
      val series2 = generateTimeSequence( "series2-500", s2 take 8, 500 )
      val series3 = generateTimeSequence( "series3-500", s3 take 8, 500 )
      val series4 = generateTimeSequence( "series4-500", s4 take 8, 500 )

      //      val e1 = massage( series1, step = 2 )
      //      trace( s"SERIES1 = ${series1.mkString(",")}" )
      //      trace( s"E1 = ${e1.mkString(",")}" )
      //      val e2 = massage( series2, step = 2 )
      //      val e3 = massage( series3, step = 2 )
      //      val e4 = massage( series4, step = 2 )

      val frames = TimeSeriesCohort.timeframes( series1.head.timestamp, series4.last.timestamp, 1000L )
      val e1 = massage( series1, frames )
      trace( s"SERIES1 = ${series1.mkString( "," )}" )
      trace( s"E1 = ${e1.mkString( "," )}" )
      val e2 = massage( series2, frames )
      val e3 = massage( series3, frames )
      val e4 = massage( series4, frames )

      val cs = e1 flatZip e2 flatZip e3 flatZip e4
      val expected = IndexedSeq( row( cs( 0 ) ), row( cs( 1 ) ), row( cs( 2 ) ), row( cs( 3 ) ) )

      val actual = TimeSeriesCohort(
        TimeSeries( topic = "series.one", points = series1 ),
        TimeSeries( topic = "series.two", points = series2 ),
        TimeSeries( topic = "series.three", points = series3 ),
        TimeSeries( topic = "series.four", points = series4 )
      )

      compareApproximateCohorts( actual.toMatrix, expected ) mustBe 0
    }

    "convert mixed cohort to matrix" in { f: Fixture ⇒
      val expected = TimeSeriesCohortSpec.mixedCohortMatrix
      val actual = TimeSeriesCohortSpec.mixedCohort.toMatrix
      actual mustBe expected
    }

    "convert off-time 2 cohort to matrix" in { f: Fixture ⇒
      pending
      import f._

      val series1 = generateTimeSequence( "series1-661", s1 take 16, 661 )
      val series2 = generateTimeSequence( "series2-1000", s2 take 8, 1000 )
      val series3 = generateTimeSequence( "series3-2000", s3 take 4, 2000 )
      val series4 = generateTimeSequence( "series4-667", s4 take 16, 667 )
      val allTimes = IndexedSeq( series1, series2, series3, series4 ).flatMap( _.map( _.timestamp ) )
      val start = allTimes.min
      val end = allTimes.max

      val frames = TimeSeriesCohort.timeframes( start, end, 1000L )
      val e1 = massage( series1, frames )
      trace( s"SERIES1 = ${series1.mkString( "," )}" )
      trace( s"E1 = ${e1.mkString( "," )}" )
      val e2 = massage( series2, frames )
      val e3 = massage( series3, frames )
      val e4 = massage( series4, frames )

      val cs = e1 flatZip e2 flatZip e3 flatZip e4
      val expected = IndexedSeq( row( cs( 0 ) ), row( cs( 1 ) ), row( cs( 2 ) ), row( cs( 3 ) ) )
      trace( s"EXPECTED=$expected" )

      val actual = TimeSeriesCohort(
        TimeSeries( topic = "series.one", points = series1 ),
        TimeSeries( topic = "series.two", points = series2 ),
        TimeSeries( topic = "series.three", points = series3 ),
        TimeSeries( topic = "series.four", points = series4 )
      )

      compareApproximateCohorts( actual.toMatrix, expected ) mustBe 0
    }

    "convert off-time cohort to matrix" in { f: Fixture ⇒
      import f._

      val series1 = generateTimeSequence( "series1-666", s1 take 16, 666 )
      val series2 = generateTimeSequence( "series2-666", s2 take 16, 666 )
      val series3 = generateTimeSequence( "series3-666", s3 take 16, 666 )
      val series4 = generateTimeSequence( "series4-666", s4 take 16, 666 )

      val frames = TimeSeriesCohort.timeframes( series1.head.timestamp, series4.last.timestamp, 1000L )
      val e1 = massage( series1, frames )
      trace( s"SERIES1 = ${series1.mkString( "," )}" )
      trace( s"E1 = ${e1.mkString( "," )}" )
      val e2 = massage( series2, frames )
      val e3 = massage( series3, frames )
      val e4 = massage( series4, frames )

      val cs = e1 flatZip e2 flatZip e3 flatZip e4
      val expected = IndexedSeq( row( cs( 0 ) ), row( cs( 1 ) ), row( cs( 2 ) ), row( cs( 3 ) ) )

      val actual = TimeSeriesCohort(
        TimeSeries( topic = "series.one", points = series1 ),
        TimeSeries( topic = "series.two", points = series2 ),
        TimeSeries( topic = "series.three", points = series3 ),
        TimeSeries( topic = "series.four", points = series4 )
      )

      compareApproximateCohorts( actual.toMatrix, expected ) mustBe 0
    }
  }
}

object TimeSeriesCohortSpec {
  def s1 = IndexedSeq(
    0.8034021258073108,
    0.6317886002224190,
    0.9305270594056617,
    0.2585858044780553,
    0.7668767448019690,
    0.7151072123356189,
    0.8149155488047959,
    0.6033127884838968,
    0.9573058709427264,
    0.1634853616052577,
    0.5470315925842234,
    0.9911521171959665,
    0.0350783910956784,
    0.1353915902952680,
    0.4682428302903453,
    0.9959659286881288
  )

  def s2 = IndexedSeq(
    0.0160711903220879,
    0.0632516286548765,
    0.2370034405095286,
    0.7233312387846997,
    0.8004926311315658,
    0.6388167145425149,
    0.9229196790544877,
    0.2845557802737965,
    0.8143351527462694,
    0.6047736469919180,
    0.9560899315840518,
    0.1679278972306196,
    0.5589124742492884,
    0.9861172815113077,
    0.0547599544642239,
    0.2070452074052003
  )

  def s3 = IndexedSeq(
    0.6567099579829515,
    0.9017679562759263,
    0.3543300372394615,
    0.9151210477973733,
    0.3106980627024436,
    0.8566591061415681,
    0.4911771280251906,
    0.9996886277204645,
    0.0012451013073562,
    0.0049742041203623,
    0.0197978456549253,
    0.0776235638493961,
    0.2863925847388594,
    0.8174874885818185,
    0.5968067783760386,
    0.9625137906418101
  )

  def s4 = IndexedSeq(
    0.1443239738645753,
    0.4939782577300506,
    0.9998549544801372,
    0.0005800979266398,
    0.0023190456521412,
    0.0092546707176180,
    0.0366760871501057,
    0.1413238071258542,
    0.4854055546612341,
    0.9991480086610151,
    0.0034050617989728,
    0.0135738694124718,
    0.0535584779265798,
    0.2027598694750713,
    0.6465932192220934,
    0.9140417123124131
  )

  val mixedCohort =
    TimeSeriesCohort(
      IndexedSeq(
        TimeSeries(
          "series.one",
          IndexedSeq(
            DataPoint( new joda.DateTime( "2015-10-15T10:45:28.595-07:00" ), 0.8034021258073109 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:29.256-07:00" ), 0.631788600222419 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:29.917-07:00" ), 0.9305270594056617 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:30.578-07:00" ), 0.2585858044780553 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:31.239-07:00" ), 0.766876744801969 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:31.900-07:00" ), 0.7151072123356189 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:32.561-07:00" ), 0.8149155488047959 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:33.222-07:00" ), 0.6033127884838968 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:33.883-07:00" ), 0.9573058709427263 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:34.544-07:00" ), 0.1634853616052577 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:35.205-07:00" ), 0.5470315925842234 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:35.866-07:00" ), 0.9911521171959665 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:36.527-07:00" ), 0.0350783910956784 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:37.188-07:00" ), 0.135391590295268 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:37.849-07:00" ), 0.4682428302903453 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:38.510-07:00" ), 0.9959659286881288 )
          )
        ),
        TimeSeries(
          "series.two",
          IndexedSeq(
            DataPoint( new joda.DateTime( "2015-10-15T10:45:28.596-07:00" ), 0.0160711903220879 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:29.596-07:00" ), 0.0632516286548765 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:30.596-07:00" ), 0.2370034405095286 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:31.596-07:00" ), 0.7233312387846997 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:32.596-07:00" ), 0.8004926311315658 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:33.596-07:00" ), 0.6388167145425149 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:34.596-07:00" ), 0.9229196790544877 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:35.596-07:00" ), 0.2845557802737965 )
          )
        ),
        TimeSeries(
          "series.three",
          IndexedSeq(
            DataPoint( new joda.DateTime( "2015-10-15T10:45:28.596-07:00" ), 0.6567099579829515 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:30.596-07:00" ), 0.9017679562759263 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:32.596-07:00" ), 0.3543300372394615 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:34.596-07:00" ), 0.9151210477973734 )
          )
        ),
        TimeSeries(
          "series.four",
          IndexedSeq(
            DataPoint( new joda.DateTime( "2015-10-15T10:45:28.597-07:00" ), 0.1443239738645753 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:29.264-07:00" ), 0.4939782577300506 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:29.931-07:00" ), 0.9998549544801372 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:30.598-07:00" ), 5.800979266398E-4 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:31.265-07:00" ), 0.0023190456521412 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:31.932-07:00" ), 0.009254670717618 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:32.599-07:00" ), 0.0366760871501057 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:33.266-07:00" ), 0.1413238071258542 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:33.933-07:00" ), 0.4854055546612341 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:34.600-07:00" ), 0.999148008661015 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:35.267-07:00" ), 0.0034050617989728 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:35.934-07:00" ), 0.0135738694124718 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:36.601-07:00" ), 0.0535584779265798 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:37.268-07:00" ), 0.2027598694750713 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:37.935-07:00" ), 0.6465932192220935 ),
            DataPoint( new joda.DateTime( "2015-10-15T10:45:38.602-07:00" ), 0.914041712312413 )
          )
        )
      ),
      SECONDS
    )

  val mixedCohortStart = new joda.DateTime( "2015-10-15T10:45:28.595-07:00" )
  val mixedCohortUnit = 1000L

  val mixedTimeFrameGroups = IndexedSeq(
    IndexedSeq( //"2015-10-15T10:45:28.595-07:00"-"2015-10-15T10:45:29.595-07:00"            1444931128595L - 1444931129595L | 1444931129095L
      IndexedSeq(
        ( new joda.DateTime( "2015-10-15T10:45:28.595-07:00" ), 0.8034021258073109 ), // 1444931128595L
        ( new joda.DateTime( "2015-10-15T10:45:29.256-07:00" ), 0.631788600222419 ) // 1444931129256L
      ),
      IndexedSeq(
        ( new joda.DateTime( "2015-10-15T10:45:28.596-07:00" ), 0.0160711903220879 ) // 1444931128596L
      ),
      IndexedSeq(
        ( new joda.DateTime( "2015-10-15T10:45:28.596-07:00" ), 0.6567099579829515 ) // 1444931128596L
      ),
      IndexedSeq(
        ( new joda.DateTime( "2015-10-15T10:45:28.597-07:00" ), 0.1443239738645753 ), // 1444931128597L
        ( new joda.DateTime( "2015-10-15T10:45:29.264-07:00" ), 0.4939782577300506 ) // 1444931129264L
      )
    ),
    IndexedSeq( //"2015-10-15T10:45:29.595-07:00"-"2015-10-15T10:45:30.595-07:00"            1444931129595L - 1444931130595L | 1444931130095L
      IndexedSeq(
        ( new joda.DateTime( "2015-10-15T10:45:29.917-07:00" ), 0.9305270594056617 ), // 1444931129917L
        ( new joda.DateTime( "2015-10-15T10:45:30.578-07:00" ), 0.2585858044780553 ) // 1444931130578L
      ),
      IndexedSeq(
        ( new joda.DateTime( "2015-10-15T10:45:29.596-07:00" ), 0.0632516286548765 ) // 1444931129596L
      ),
      IndexedSeq(),
      IndexedSeq(
        ( new joda.DateTime( "2015-10-15T10:45:29.931-07:00" ), 0.9998549544801372 ) // 1444931129931L
      )
    ),
    IndexedSeq( //"2015-10-15T10:45:30.595-07:00"-"2015-10-15T10:45:31.595-07:00"            1444931130595L - 1444931131595L | 1444931131095L
      IndexedSeq(
        ( new joda.DateTime( "2015-10-15T10:45:31.239-07:00" ), 0.766876744801969 ) // 1444931131239L
      ),
      IndexedSeq(
        ( new joda.DateTime( "2015-10-15T10:45:30.596-07:00" ), 0.2370034405095286 ) // 1444931130596L
      ),
      IndexedSeq(
        ( new joda.DateTime( "2015-10-15T10:45:30.596-07:00" ), 0.9017679562759263 ) // 1444931130596L
      ),
      IndexedSeq(
        ( new joda.DateTime( "2015-10-15T10:45:30.598-07:00" ), 5.800979266398E-4 ), // 1444931130598L
        ( new joda.DateTime( "2015-10-15T10:45:31.265-07:00" ), 0.0023190456521412 ) // 1444931131265L
      )
    ),
    IndexedSeq( //"2015-10-15T10:45:31.595-07:00"-"2015-10-15T10:45:32.595-07:00"            1444931131595L - 1444931132595L | 1444931132095L
      IndexedSeq(
        ( new joda.DateTime( "2015-10-15T10:45:31.900-07:00" ), 0.7151072123356189 ), // 1444931131900L
        ( new joda.DateTime( "2015-10-15T10:45:32.561-07:00" ), 0.8149155488047959 ) // 1444931132561L
      ),
      IndexedSeq(
        ( new joda.DateTime( "2015-10-15T10:45:31.596-07:00" ), 0.7233312387846997 ) // 1444931131596L
      ),
      IndexedSeq(),
      IndexedSeq(
        ( new joda.DateTime( "2015-10-15T10:45:31.932-07:00" ), 0.009254670717618 ) // 1444931131932L
      )
    ),
    IndexedSeq( //"2015-10-15T10:45:32.595-07:00"-"2015-10-15T10:45:33.595-07:00"            1444931132595L - 1444931133595L | 1444931133095L
      IndexedSeq(
        ( new joda.DateTime( "2015-10-15T10:45:33.222-07:00" ), 0.6033127884838968 ) // 1444931133222L
      ),
      IndexedSeq(
        ( new joda.DateTime( "2015-10-15T10:45:32.596-07:00" ), 0.8004926311315658 ) // 1444931132596L
      ),
      IndexedSeq(
        ( new joda.DateTime( "2015-10-15T10:45:32.596-07:00" ), 0.3543300372394615 ) // 1444931132596L
      ),
      IndexedSeq(
        ( new joda.DateTime( "2015-10-15T10:45:32.599-07:00" ), 0.0366760871501057 ), // 1444931132599L
        ( new joda.DateTime( "2015-10-15T10:45:33.266-07:00" ), 0.1413238071258542 ) // 1444931133266L
      )
    ),
    IndexedSeq( //"2015-10-15T10:45:33.595-07:00"-"2015-10-15T10:45:34.595-07:00"            1444931133595L - 1444931134595L | 1444931134095L
      IndexedSeq(
        ( new joda.DateTime( "2015-10-15T10:45:33.883-07:00" ), 0.9573058709427263 ), // 1444931133883L
        ( new joda.DateTime( "2015-10-15T10:45:34.544-07:00" ), 0.1634853616052577 ) // 1444931134544L
      ),
      IndexedSeq(
        ( new joda.DateTime( "2015-10-15T10:45:33.596-07:00" ), 0.6388167145425149 ) // 1444931133596L
      ),
      IndexedSeq(),
      IndexedSeq(
        ( new joda.DateTime( "2015-10-15T10:45:33.933-07:00" ), 0.4854055546612341 ) // 1444931133933L
      )
    ),
    IndexedSeq( //"2015-10-15T10:45:34.595-07:00"-"2015-10-15T10:45:35.595-07:00"            1444931134595L - 1444931135595L | 1444931135095L
      IndexedSeq(
        ( new joda.DateTime( "2015-10-15T10:45:35.205-07:00" ), 0.5470315925842234 ) // 1444931135205L
      ),
      IndexedSeq(
        ( new joda.DateTime( "2015-10-15T10:45:34.596-07:00" ), 0.9229196790544877 ) // 1444931134596L
      ),
      IndexedSeq(
        ( new joda.DateTime( "2015-10-15T10:45:34.596-07:00" ), 0.9151210477973734 ) // 1444931134596L
      ),
      IndexedSeq(
        ( new joda.DateTime( "2015-10-15T10:45:34.600-07:00" ), 0.999148008661015 ), // 1444931134600L
        ( new joda.DateTime( "2015-10-15T10:45:35.267-07:00" ), 0.0034050617989728 ) // 1444931135267L
      )
    ),
    IndexedSeq( //"2015-10-15T10:45:35.595-07:00"-"2015-10-15T10:45:36.595-07:00"            1444931135595L - 1444931136595L | 1444931136095L
      IndexedSeq(
        ( new joda.DateTime( "2015-10-15T10:45:35.866-07:00" ), 0.9911521171959665 ), // 1444931135866L
        ( new joda.DateTime( "2015-10-15T10:45:36.527-07:00" ), 0.0350783910956784 ) // 1444931136527L
      ),
      IndexedSeq(
        ( new joda.DateTime( "2015-10-15T10:45:35.596-07:00" ), 0.2845557802737965 ) // 1444931135596L
      ),
      IndexedSeq(),
      IndexedSeq(
        ( new joda.DateTime( "2015-10-15T10:45:35.934-07:00" ), 0.0135738694124718 ) // 1444931135934L
      )
    ),
    IndexedSeq( //"2015-10-15T10:45:36.595-07:00"-"2015-10-15T10:45:37.595-07:00"            1444931136595L - 1444931137595L | 1444931137095L
      IndexedSeq(
        ( new joda.DateTime( "2015-10-15T10:45:37.188-07:00" ), 0.135391590295268 ) // 1444931137188L
      ),
      IndexedSeq(),
      IndexedSeq(),
      IndexedSeq(
        ( new joda.DateTime( "2015-10-15T10:45:36.601-07:00" ), 0.0535584779265798 ), // 1444931136601L
        ( new joda.DateTime( "2015-10-15T10:45:37.268-07:00" ), 0.2027598694750713 ) // 1444931137268L
      )
    ),
    IndexedSeq( //"2015-10-15T10:45:37.595-07:00"-"2015-10-15T10:45:38.595-07:00"            1444931137595L - 1444931138595L | 1444931138095L
      IndexedSeq(
        ( new joda.DateTime( "2015-10-15T10:45:37.849-07:00" ), 0.4682428302903453 ), // 1444931137849L
        ( new joda.DateTime( "2015-10-15T10:45:38.510-07:00" ), 0.9959659286881288 ) // 1444931138510L
      ),
      IndexedSeq(),
      IndexedSeq(),
      IndexedSeq(
        ( new joda.DateTime( "2015-10-15T10:45:37.935-07:00" ), 0.6465932192220935 ) // 1444931137935L
      )
    ),
    IndexedSeq( // "2015-10-15T10:45:38.595-07:00"-"2015-10-15T10:45:39.595-07:00"           1444931138595L - 1444931139595L | 1444931139095L
      IndexedSeq(),
      IndexedSeq(),
      IndexedSeq(),
      IndexedSeq(
        ( new joda.DateTime( "2015-10-15T10:45:38.602-07:00" ), 0.914041712312413 ) // 1444931138602L
      )
    )
  )

  val mixedCohortMatrix: Matrix[( joda.DateTime, Double )] = IndexedSeq(
    IndexedSeq( //"2015-10-15T10:45:28.595-07:00"-"2015-10-15T10:45:29.595-07:00"            1444931128595L - 1444931129595L | 1444931129095L
      ( new joda.DateTime( 1444931129095L ), 0.6735885663633685 ),
      ( new joda.DateTime( "2015-10-15T10:45:28.596-07:00" ), 0.0160711903220879 ), // 1444931128596L
      ( new joda.DateTime( "2015-10-15T10:45:28.596-07:00" ), 0.6567099579829515 ), // 1444931128596L
      ( new joda.DateTime( 1444931129095L ), 0.40538519330236644 ) // 1444931128597L
    ),
    IndexedSeq( //"2015-10-15T10:45:29.595-07:00"-"2015-10-15T10:45:30.595-07:00"            1444931129595L - 1444931130595L | 1444931130095L
      ( new joda.DateTime( 1444931130095L ), 0.7495807002874864 ),
      ( new joda.DateTime( "2015-10-15T10:45:29.596-07:00" ), 0.0632516286548765 ), // 1444931129596L
      ( new joda.DateTime( "2015-10-15T10:45:29.931-07:00" ), 0.9998549544801372 ) // 1444931129931L
    ),
    IndexedSeq( //"2015-10-15T10:45:30.595-07:00"-"2015-10-15T10:45:31.595-07:00"            1444931130595L - 1444931131595L | 1444931131095L
      ( new joda.DateTime( "2015-10-15T10:45:31.239-07:00" ), 0.766876744801969 ), // 1444931131239L
      ( new joda.DateTime( "2015-10-15T10:45:30.596-07:00" ), 0.2370034405095286 ), // 1444931130596L
      ( new joda.DateTime( "2015-10-15T10:45:30.596-07:00" ), 0.9017679562759263 ), // 1444931130596L
      ( new joda.DateTime( 1444931131095L ), 0.0018758355871708282 )
    ),
    IndexedSeq( //"2015-10-15T10:45:31.595-07:00"-"2015-10-15T10:45:32.595-07:00"            1444931131595L - 1444931132595L | 1444931132095L
      ( new joda.DateTime( 1444931132095L ), 0.7445514265738784 ),
      ( new joda.DateTime( "2015-10-15T10:45:31.596-07:00" ), 0.7233312387846997 ), // 1444931131596L
      ( new joda.DateTime( "2015-10-15T10:45:31.932-07:00" ), 0.009254670717618 ) // 1444931131932L
    ),
    IndexedSeq( //"2015-10-15T10:45:32.595-07:00"-"2015-10-15T10:45:33.595-07:00"            1444931132595L - 1444931133595L | 1444931133095L
      ( new joda.DateTime( "2015-10-15T10:45:33.222-07:00" ), 0.6033127884838968 ), // 1444931133222L
      ( new joda.DateTime( "2015-10-15T10:45:32.596-07:00" ), 0.8004926311315658 ), // 1444931132596L
      ( new joda.DateTime( "2015-10-15T10:45:32.596-07:00" ), 0.3543300372394615 ), // 1444931132596L
      ( new joda.DateTime( 1444931133095L ), 0.11449508131498015 )
    ),
    IndexedSeq( //"2015-10-15T10:45:33.595-07:00"-"2015-10-15T10:45:34.595-07:00"            1444931133595L - 1444931134595L | 1444931134095L
      ( new joda.DateTime( 1444931134095L ), 0.7027068573579407 ),
      ( new joda.DateTime( "2015-10-15T10:45:33.596-07:00" ), 0.6388167145425149 ), // 1444931133596L
      ( new joda.DateTime( "2015-10-15T10:45:33.933-07:00" ), 0.4854055546612341 ) // 1444931133933L
    ),
    IndexedSeq( //"2015-10-15T10:45:34.595-07:00"-"2015-10-15T10:45:35.595-07:00"            1444931134595L - 1444931135595L | 1444931135095L
      ( new joda.DateTime( "2015-10-15T10:45:35.205-07:00" ), 0.5470315925842234 ), // 1444931135205L
      ( new joda.DateTime( "2015-10-15T10:45:34.596-07:00" ), 0.9229196790544877 ), // 1444931134596L
      ( new joda.DateTime( "2015-10-15T10:45:34.596-07:00" ), 0.9151210477973734 ), // 1444931134596L
      ( new joda.DateTime( 1444931135095L ), 0.26017835544255796 )
    ),
    IndexedSeq( //"2015-10-15T10:45:35.595-07:00"-"2015-10-15T10:45:36.595-07:00"            1444931135595L - 1444931136595L | 1444931136095L
      ( new joda.DateTime( 1444931136095L ), 0.6599253648858818 ),
      ( new joda.DateTime( "2015-10-15T10:45:35.596-07:00" ), 0.2845557802737965 ), // 1444931135596L
      ( new joda.DateTime( "2015-10-15T10:45:35.934-07:00" ), 0.0135738694124718 ) // 1444931135934L
    ),
    IndexedSeq( //"2015-10-15T10:45:36.595-07:00"-"2015-10-15T10:45:37.595-07:00"            1444931136595L - 1444931137595L | 1444931137095L
      ( new joda.DateTime( "2015-10-15T10:45:37.188-07:00" ), 0.135391590295268 ), // 1444931137188L
      ( new joda.DateTime( 1444931137095L ), 0.1640614575741882 )
    ),
    IndexedSeq( //"2015-10-15T10:45:37.595-07:00"-"2015-10-15T10:45:38.595-07:00"            1444931137595L - 1444931138595L | 1444931138095L
      ( new joda.DateTime( 1444931138095L ), 0.6646420469406551 ),
      ( new joda.DateTime( "2015-10-15T10:45:37.935-07:00" ), 0.6465932192220935 ) // 1444931137935L
    ),
    IndexedSeq( // "2015-10-15T10:45:38.595-07:00"-"2015-10-15T10:45:39.595-07:00"           1444931138595L - 1444931139595L | 1444931139095L
      ( new joda.DateTime( "2015-10-15T10:45:38.602-07:00" ), 0.914041712312413 ) // 1444931138602L
    )
  )
}

//    def massageOld( series: Row[DataPoint], step: Int ): Row[DataPoint] = {
//      def reduce( series: Row[DataPoint], step: Int ): Row[Row[DataPoint]] = {
//        @tailrec def loop( data: List[DataPoint], acc: Row[Row[DataPoint]] ): Row[Row[DataPoint]] = {
//          if ( data.isEmpty ) acc
//          else {
//            val cur = data take step
//            loop( data drop step, acc :+ cur.toIndexedSeq )
//          }
//        }
//
//        loop( series.toList, IndexedSeq.empty[IndexedSeq[DataPoint]] )
//      }
//
//      def midFor( start: joda.DateTime, precision: TimeUnit )( pt: joda.DateTime ): joda.DateTime = trace.block( s"midFor($start, $precision)( $pt )" ) {
//        @tailrec def loop( start: joda.DateTime, end: joda.DateTime ): joda.DateTime = {
//          trace( s"loop( $start, $end )" )
//          if ( start isEqual pt ) new joda.DateTime( ( (start.getMillis.toDouble + end.getMillis.toDouble) / 2.0 ).toLong )
//          else if ( start.isBefore(pt) && pt.isBefore(end) ) new joda.DateTime( ( (start.getMillis.toDouble + end.getMillis.toDouble) / 2.0 ).toLong )
//          else loop( end, end + precision.toMillis(1) )
//        }
//
//        loop( start, (start + precision.toMillis(1)) )
//      }
//
//      for {
//        intermediate <- reduce( series, step )
//        xs = intermediate map { _.timestamp.getMillis.toDouble }
//        ys = intermediate map { _.value }
//      } yield {
//        if ( intermediate.isEmpty ) DataPoint( new joda.DateTime(0L), 0D )
//        else if ( intermediate.size == 1 ) DataPoint( new joda.DateTime(xs.head.toLong), ys.head )
//        else {
//          val result = Interpolator( xs.toArray, ys.toArray ) map { interpolate =>
//            val mid = midFor( series.head.timestamp, SECONDS )( new joda.DateTime(xs.head.toLong) )
//            val value = interpolate( mid.getMillis.toDouble )
//            DataPoint( mid, value )
//          }
//          result.valueOr( exs => throw exs.head )
//        }
//      }
//    }
